// Generated by CoffeeScript 1.7.1
var Digest, LEADING_SLASH_RE, crypto, fs, glob, pathlib, warn,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

crypto = require('crypto');

fs = require('fs');

pathlib = require('path');

glob = require('glob');

LEADING_SLASH_RE = /^\//;

warn = function(message) {
  return console.warn("digest-brunch WARNING: " + message);
};

Digest = (function() {
  Digest.prototype.brunchPlugin = true;

  function Digest(config) {
    var cfg, flags, k, needle, _ref, _ref1;
    this.config = config;
    this.options = {
      pattern: /DIGEST\((\/?[^\)]*)\)/g,
      discardNonFilenamePatternParts: true,
      referenceFiles: /\.html$/,
      precision: 8,
      alwaysRun: false,
      environments: ['production'],
      prependHost: null,
      manifest: ''
    };
    cfg = (_ref = (_ref1 = this.config.plugins) != null ? _ref1.digest : void 0) != null ? _ref : {};
    for (k in cfg) {
      this.options[k] = cfg[k];
    }
    needle = this.options.pattern.source || this.options.pattern || '';
    flags = 'g';
    if (this.options.pattern.ignoreCase) {
      flags += 'i';
    }
    if (this.options.pattern.multiline) {
      flags += 'm';
    }
    this.options.pattern = new RegExp(needle, flags);
  }

  Digest.prototype.onCompile = function() {
    var allFiles, filesAndDigests, filesToDigest, referenceFiles, renameMap, _ref, _ref1;
    this.publicFolder = this.config.paths["public"];
    allFiles = glob.sync("" + this.publicFolder + "/**");
    referenceFiles = this._referenceFiles(allFiles);
    if ((_ref = this.config.env[0], __indexOf.call(this.options.environments, _ref) < 0) && !this.options.alwaysRun) {
      return this._removeReferences(referenceFiles);
    } else {
      if ((_ref1 = this.config.server) != null ? _ref1.run : void 0) {
        warn('Not intended to be run with on-demand compilation (brunch watch)');
      }
      if (this.options.precision < 6) {
        warn('Name collision more likely when less than 6 digits of SHA used.');
      }
      filesToDigest = this._filesToDigest(referenceFiles);
      filesAndDigests = this._filesAndDigests(filesToDigest);
      renameMap = this._renameMap(filesAndDigests);
      if (this.options.manifest) {
        fs.writeFileSync(this.options.manifest, JSON.stringify(renameMap, null, 4));
      }
      return this._renameAndReplace(referenceFiles, renameMap);
    }
  };

  Digest.prototype._validDigestFile = function(file) {
    if (!fs.existsSync(file)) {
      warn("Missing hashed version of file " + file + ". Skipping.");
      return false;
    }
    return fs.statSync(file).isFile();
  };

  Digest.prototype._referenceFiles = function(files) {
    var file, referenceFiles, _i, _len;
    referenceFiles = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      if (this.options.referenceFiles.test(file)) {
        referenceFiles.push(file);
      }
    }
    return referenceFiles;
  };

  Digest.prototype._filesToDigest = function(files) {
    var contents, file, filesToDigest, match, _i, _len;
    filesToDigest = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      this.options.pattern.lastIndex = 0;
      contents = fs.readFileSync(file).toString();
      match = this.options.pattern.exec(contents);
      while (match !== null) {
        filesToDigest.push(match[1]);
        match = this.options.pattern.exec(contents);
      }
    }
    return filesToDigest;
  };

  Digest.prototype._filesAndDigests = function(files) {
    var data, file, filesAndDigests, hasLeadingSlash, precision, relativePath, shasum, _i, _len;
    precision = this.options.precision;
    filesAndDigests = {};
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      hasLeadingSlash = LEADING_SLASH_RE.test(file);
      file = pathlib.join(this.publicFolder, file);
      if (this._validDigestFile(file)) {
        data = fs.readFileSync(file);
        shasum = crypto.createHash('sha1');
        shasum.update(data);
        relativePath = pathlib.relative(this.publicFolder, file);
        if (hasLeadingSlash) {
          relativePath = "/" + relativePath;
        }
        filesAndDigests[relativePath] = shasum.digest('hex').slice(0, +(precision - 1) + 1 || 9e9);
      }
    }
    return filesAndDigests;
  };

  Digest.prototype._renameAndReplace = function(referenceFiles, renameMap) {
    var nameMap, newFilename, newPath, originalFilename, originalPath;
    nameMap = {};
    for (originalFilename in renameMap) {
      newFilename = renameMap[originalFilename];
      originalPath = pathlib.join(this.publicFolder, originalFilename);
      newPath = pathlib.join(this.publicFolder, newFilename);
      nameMap[originalPath] = newPath;
    }
    for (originalPath in nameMap) {
      newPath = nameMap[originalPath];
      fs.renameSync(originalPath, newPath);
    }
    return this._replaceReferences(referenceFiles, renameMap);
  };

  Digest.prototype._renameMap = function(filesAndDigests) {
    var digest, digestFilename, digestPath, directory, extname, filename, path, renameMap;
    renameMap = {};
    for (path in filesAndDigests) {
      digest = filesAndDigests[path];
      directory = pathlib.dirname(path);
      extname = pathlib.extname(path);
      filename = pathlib.basename(path, extname);
      digestFilename = "" + filename + "-" + digest + extname;
      digestPath = pathlib.join(directory, digestFilename);
      renameMap[path] = digestPath;
    }
    return renameMap;
  };

  Digest.prototype._escapeRegExp = function(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  };

  Digest.prototype._replaceReferences = function(referenceFiles, renamedFiles) {
    var contents, findRegExp, match, originalFilename, originalString, processedString, referenceFile, replacementFilename, replacementMap, _i, _len, _ref, _results;
    _results = [];
    for (_i = 0, _len = referenceFiles.length; _i < _len; _i++) {
      referenceFile = referenceFiles[_i];
      replacementMap = {};
      this.options.pattern.lastIndex = 0;
      if (!fs.existsSync(referenceFile)) {
        continue;
      }
      contents = fs.readFileSync(referenceFile).toString();
      match = this.options.pattern.exec(contents);
      while (match !== null) {
        originalFilename = match[1];
        replacementFilename = renamedFiles[originalFilename];
        if (((_ref = this.options.prependHost) != null ? _ref[this.config.env[0]] : void 0) != null) {
          replacementFilename = this.options.prependHost[this.config.env[0]] + replacementFilename;
        }
        replacementMap[this.options.discardNonFilenamePatternParts ? match[0] : originalFilename] = replacementFilename || originalFilename;
        match = this.options.pattern.exec(contents);
      }
      for (originalString in replacementMap) {
        processedString = replacementMap[originalString];
        findRegExp = new RegExp(this._escapeRegExp(originalString), 'g');
        contents = contents.replace(findRegExp, processedString);
      }
      _results.push(fs.writeFileSync(referenceFile, contents));
    }
    return _results;
  };

  Digest.prototype._removeReferences = function(files) {
    var contents, file, _i, _len, _results;
    if (!this.options.discardNonFilenamePatternParts) {
      return;
    }
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      contents = fs.readFileSync(file).toString();
      contents = contents.replace(this.options.pattern, '$1');
      _results.push(fs.writeFileSync(file, contents));
    }
    return _results;
  };

  return Digest;

})();

module.exports = Digest;
