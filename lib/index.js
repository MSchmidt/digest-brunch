// Generated by CoffeeScript 1.6.3
var DIGEST_RE, Digest, crypto, fs, glob, pathlib, warn;

crypto = require('crypto');

fs = require('fs');

pathlib = require('path');

glob = require('glob');

DIGEST_RE = "DIGEST\\((.+?)\\)";

warn = function(message) {
  return console.error("WARNING (brunch-digest): " + message);
};

Digest = (function() {
  Digest.prototype.brunchPlugin = true;

  function Digest(config) {
    var cfg, k, _ref, _ref1;
    this.config = config;
    this.options = {
      referenceFiles: /\.html$/,
      precision: 8,
      alwaysRun: false
    };
    cfg = (_ref = (_ref1 = this.config.plugins) != null ? _ref1.digest : void 0) != null ? _ref : {};
    for (k in cfg) {
      this.options[k] = cfg[k];
    }
  }

  Digest.prototype.onCompile = function() {
    var allFiles, filesAndDigests, filesToDigest, referenceFiles, renameMap;
    this.publicFolder = this.config.paths["public"];
    allFiles = glob.sync("" + this.publicFolder + "/**");
    referenceFiles = this._referenceFiles(allFiles);
    if (this.config.env.indexOf('production') === -1 && !this.options.alwaysRun) {
      return this._removeReferences(referenceFiles);
    } else {
      if (this.options.precision < 6) {
        warn('Name collision possible when less than 6 digits of SHA used.');
      }
      filesToDigest = this._filesToDigest(referenceFiles);
      filesAndDigests = this._filesAndDigests(filesToDigest);
      renameMap = this._renameMap(filesAndDigests);
      return this._renameAndReplace(referenceFiles, renameMap);
    }
  };

  Digest.prototype._isFile = function(file) {
    return fs.statSync(file).isFile();
  };

  Digest.prototype._validDigestFile = function(file) {
    return this._isFile(file);
  };

  Digest.prototype._referenceFiles = function(files) {
    var file, referenceFiles, _i, _len;
    referenceFiles = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      if (this.options.referenceFiles.test(file)) {
        referenceFiles.push(file);
      }
    }
    return referenceFiles;
  };

  Digest.prototype._filesToDigest = function(files) {
    var contents, digestRe, file, filesToDigest, match, _i, _len;
    filesToDigest = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      digestRe = new RegExp(DIGEST_RE, 'g');
      contents = fs.readFileSync(file).toString();
      match = digestRe.exec(contents);
      while (match !== null) {
        filesToDigest.push(match[1]);
        match = digestRe.exec(contents);
      }
    }
    return filesToDigest;
  };

  Digest.prototype._filesAndDigests = function(files) {
    var data, file, filesAndDigests, precision, relativePath, shasum, _i, _len;
    precision = this.options.precision;
    filesAndDigests = {};
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      file = pathlib.join(this.publicFolder, file);
      if (this._validDigestFile(file)) {
        data = fs.readFileSync(file);
        shasum = crypto.createHash('sha1');
        shasum.update(data);
        relativePath = pathlib.relative(this.publicFolder, file);
        filesAndDigests[relativePath] = shasum.digest('hex').slice(0, +(precision - 1) + 1 || 9e9);
      }
    }
    return filesAndDigests;
  };

  Digest.prototype._renameAndReplace = function(referenceFiles, renameMap) {
    var newFilename, newPath, originalFilename, originalPath;
    for (originalFilename in renameMap) {
      newFilename = renameMap[originalFilename];
      originalPath = pathlib.join(this.publicFolder, originalFilename);
      newPath = pathlib.join(this.publicFolder, newFilename);
      fs.renameSync(originalPath, newPath);
    }
    return this._replaceReferences(referenceFiles, renameMap);
  };

  Digest.prototype._renameMap = function(filesAndDigests) {
    var digest, digestFilename, digestPath, directory, extname, filename, path, renameMap;
    renameMap = {};
    for (path in filesAndDigests) {
      digest = filesAndDigests[path];
      directory = pathlib.dirname(path);
      extname = pathlib.extname(path);
      filename = pathlib.basename(path, extname);
      digestFilename = "" + filename + "-" + digest + extname;
      digestPath = pathlib.join(directory, digestFilename);
      renameMap[path] = digestPath;
    }
    return renameMap;
  };

  Digest.prototype._replaceReferences = function(referenceFiles, renamedFiles) {
    var contents, escaped, fileRe, originalFile, referenceFile, renamedFile, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = referenceFiles.length; _i < _len; _i++) {
      referenceFile = referenceFiles[_i];
      contents = fs.readFileSync(referenceFile).toString();
      for (originalFile in renamedFiles) {
        renamedFile = renamedFiles[originalFile];
        escaped = originalFile.replace('.', "\\.");
        fileRe = new RegExp("DIGEST\\(" + escaped + "\\)", 'g');
        contents = contents.replace(fileRe, renamedFile);
      }
      _results.push(fs.writeFileSync(referenceFile, contents));
    }
    return _results;
  };

  Digest.prototype._removeReferences = function(files) {
    var contents, digestRe, file, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      contents = fs.readFileSync(file).toString();
      digestRe = new RegExp(DIGEST_RE, 'g');
      contents = contents.replace(digestRe, '$1');
      _results.push(fs.writeFileSync(file, contents));
    }
    return _results;
  };

  return Digest;

})();

module.exports = Digest;
